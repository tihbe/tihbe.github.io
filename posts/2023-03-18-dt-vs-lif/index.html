<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.30">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Ismael Balafrej">
<meta name="dcterms.date" content="2023-03-19">
<meta name="description" content="What is the proper timestep to select when simulating a spiking neural network ? The answer is, of course, it depends. Although, I think the usual assumption is incorrect when using leaky-integrate-and-fire neurons. Here’s why !">

<title>Selection of a timestep for SNN simulation – Ismael Balafrej</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-de070a7b0ab54f8780927367ac907214.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-3406a2ba0a52e2b10a4240cfc86af220.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-VPT77KYSBR"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-VPT77KYSBR', { 'anonymize_ip': true});
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jpswalsh/academicons@1/css/academicons.min.css">
<meta name="twitter:title" content="Selection of a timestep for SNN simulation – Ismael Balafrej">
<meta name="twitter:description" content="What is the proper timestep to select when simulating a spiking neural network ? The answer is, of course, it depends. Although, I think the usual assumption is incorrect when using leaky-integrate-and-fire neurons. Here’s why !">
<meta name="twitter:image" content="https://ibalafrej.com/posts/2023-03-18-dt-vs-lif/index_files/figure-html/cell-2-output-1.png">
<meta name="twitter:creator" content="@IsmaelBalafrej">
<meta name="twitter:site" content="@IsmaelBalafrej">
<meta name="twitter:image-height" content="748">
<meta name="twitter:image-width" content="1132">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Ismael Balafrej</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html"> 
<span class="menu-text">Posts</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../publications.html"> 
<span class="menu-text">Publications</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/tihbe"> <i class="bi bi-github" role="img" aria-label="GitHub">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/IsmaelBalafrej"> <i class="bi bi-twitter" role="img" aria-label="Twitter">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://linkedin.com/in/IsmaelBalafrej"> <i class="bi bi-linkedin" role="img" aria-label="LinkedIn">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#context" id="toc-context" class="nav-link active" data-scroll-target="#context">Context</a></li>
  <li><a href="#recreating-the-simulation" id="toc-recreating-the-simulation" class="nav-link" data-scroll-target="#recreating-the-simulation">Recreating the Simulation</a></li>
  <li><a href="#hypothesis" id="toc-hypothesis" class="nav-link" data-scroll-target="#hypothesis">Hypothesis</a></li>
  <li><a href="#solution" id="toc-solution" class="nav-link" data-scroll-target="#solution">Solution</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Selection of a timestep for SNN simulation</h1>
  <div class="quarto-categories">
    <div class="quarto-category">SNN</div>
    <div class="quarto-category">LIF</div>
  </div>
  </div>

<div>
  <div class="description">
    What is the proper timestep to select when simulating a spiking neural network ? The answer is, of course, it depends. Although, I think the usual assumption is incorrect when using leaky-integrate-and-fire neurons. Here’s why !
  </div>
</div>


<div class="quarto-title-meta column-page-left">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Ismael Balafrej </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">March 19, 2023</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="context" class="level1">
<h1>Context</h1>
<p>I recently came across <a href="https://twitter.com/neuralreckoning/status/1580161403415330816">a tweet</a> by Dan Goodman, which presented a brief experiment demonstrating the detrimental effects of using a large timestep (<span class="math inline">\(\delta t\)</span>) during the simulation of a LIF neuron. The output spiking rate of a LIF neuron with a Poisson spike input was found to decrease as the timestep increased, with failure observed at soon as <span class="math inline">\(\delta t=1\)</span> ms - a standard timestep size within the CS-oriented community.</p>
<p>Of course, there is a direct relationship between the choice of <span class="math inline">\(\delta t\)</span>, and real-world simulation duration (or wall-clock time). Ideally, we would all be using a very large <span class="math inline">\(\delta t\)</span> for our simulation. As <a href="https://twitter.com/BellecGuill/status/1580440789217595394">Guillaume Bellec</a> pointed out, there might not even be any advantage in a machine learning setting to using a small <span class="math inline">\(\delta t\)</span>.</p>
<p>Rather than accepting the necessity of a small timestep, it is worth investigating why the simulation fails, even when employing an exact solver instead of Euler’s method. Specifically, there should only be a small distinction when the spike arrives at the beginning, or the end, of a clock cycle. We somewhat over or underestimate the membrane potential by <span class="math inline">\(w\exp(\frac{-\delta t}{\tau})\)</span> depending on when the spike arrived during the clock period.</p>
</section>
<section id="recreating-the-simulation" class="level1">
<h1>Recreating the Simulation</h1>
<p>A straightforward experiment can be devised to replicate the behavior outlined in the tweet. We will simulate 100 LIF neurons, being stimulated by 100 Poisson spike trains sampled at 5 Hz for 4 seconds. The LIF’s time constant is <span class="math inline">\(\tau=10\)</span> ms. The weights between the 100 inputs and 100 output neurons are randomly sampled from a normal distribution <span class="math inline">\(\mathcal{N}(0.1, 0.25)\)</span>. We then compute the mean output firing rate of every output neuron, and the corresponding standard deviation as error bars.</p>
<div class="cell" data-execution_count="1">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-3"><a href="#cb1-3"></a></span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="co"># Configuration</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>np.random.seed(<span class="bn">0x1B</span>)</span>
<span id="cb1-6"><a href="#cb1-6"></a>duration <span class="op">=</span> <span class="dv">4</span> <span class="co"># seconds</span></span>
<span id="cb1-7"><a href="#cb1-7"></a>tau <span class="op">=</span> <span class="fl">0.010</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>thresh <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb1-9"><a href="#cb1-9"></a>nb_inputs <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb1-10"><a href="#cb1-10"></a>nb_outputs <span class="op">=</span> <span class="dv">1000</span></span>
<span id="cb1-11"><a href="#cb1-11"></a>input_rate <span class="op">=</span> <span class="dv">5</span> <span class="co">#Hz</span></span>
<span id="cb1-12"><a href="#cb1-12"></a>weights <span class="op">=</span> np.random.randn(nb_outputs, nb_inputs)<span class="op">*</span><span class="fl">0.5</span><span class="op">+</span><span class="fl">0.1</span></span>
<span id="cb1-13"><a href="#cb1-13"></a>dts <span class="op">=</span> np.logspace(<span class="op">-</span><span class="dv">5</span>, <span class="op">-</span><span class="fl">1.5</span>, <span class="dv">10</span>) <span class="co"># in seconds</span></span>
<span id="cb1-14"><a href="#cb1-14"></a></span>
<span id="cb1-15"><a href="#cb1-15"></a><span class="co"># Simulation</span></span>
<span id="cb1-16"><a href="#cb1-16"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">4</span>), tight_layout<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb1-17"><a href="#cb1-17"></a>spike_rates <span class="op">=</span> np.zeros((<span class="bu">len</span>(dts), nb_outputs)) <span class="co"># output</span></span>
<span id="cb1-18"><a href="#cb1-18"></a><span class="cf">for</span> i, dt <span class="kw">in</span> <span class="bu">enumerate</span>(dts):</span>
<span id="cb1-19"><a href="#cb1-19"></a>    time <span class="op">=</span> np.arange(<span class="dv">0</span>, duration, dt)</span>
<span id="cb1-20"><a href="#cb1-20"></a>    u <span class="op">=</span> np.zeros(nb_outputs)</span>
<span id="cb1-21"><a href="#cb1-21"></a>    _exp <span class="op">=</span> np.exp(<span class="op">-</span>dt<span class="op">/</span>tau)</span>
<span id="cb1-22"><a href="#cb1-22"></a>    input_spikes <span class="op">=</span> np.random.poisson(lam<span class="op">=</span>input_rate<span class="op">*</span>dt, size<span class="op">=</span>(<span class="bu">len</span>(time), nb_inputs))</span>
<span id="cb1-23"><a href="#cb1-23"></a>    weighted_input_spikes <span class="op">=</span> input_spikes <span class="op">@</span> weights.T</span>
<span id="cb1-24"><a href="#cb1-24"></a>    spike_count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb1-25"><a href="#cb1-25"></a></span>
<span id="cb1-26"><a href="#cb1-26"></a>    <span class="cf">for</span> j, t <span class="kw">in</span> <span class="bu">enumerate</span>(time):</span>
<span id="cb1-27"><a href="#cb1-27"></a>        u <span class="op">=</span> _exp <span class="op">*</span> u <span class="op">+</span> weighted_input_spikes[j]</span>
<span id="cb1-28"><a href="#cb1-28"></a>        spikes <span class="op">=</span> u <span class="op">&gt;</span> thresh</span>
<span id="cb1-29"><a href="#cb1-29"></a>        spike_count <span class="op">+=</span> spikes</span>
<span id="cb1-30"><a href="#cb1-30"></a>        u[spikes] <span class="op">=</span> <span class="dv">0</span> <span class="co"># reset</span></span>
<span id="cb1-31"><a href="#cb1-31"></a>    spike_rates[i] <span class="op">+=</span> spike_count <span class="op">/</span> duration</span>
<span id="cb1-32"><a href="#cb1-32"></a>ax.errorbar(dts<span class="op">*</span><span class="dv">1000</span>, spike_rates.mean(axis<span class="op">=</span><span class="dv">1</span>), yerr<span class="op">=</span>spike_rates.std(axis<span class="op">=</span><span class="dv">1</span>), capsize<span class="op">=</span><span class="dv">5</span>,)</span>
<span id="cb1-33"><a href="#cb1-33"></a>ax.set_xscale(<span class="st">"log"</span>)</span>
<span id="cb1-34"><a href="#cb1-34"></a>ax.set_xlabel(<span class="st">"$</span><span class="ch">\\</span><span class="st">delta t$ [ms]"</span>)</span>
<span id="cb1-35"><a href="#cb1-35"></a>ax.set_ylabel(<span class="st">"Output firing rate [sp/s]"</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-2-output-1.png" width="566" height="374" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>We arrive at a similar-looking plot, where the output spiking frequency is going down near <span class="math inline">\(\delta t=1\)</span> ms.</p>
</section>
<section id="hypothesis" class="level1">
<h1>Hypothesis</h1>
<p>Numerous commenters in the original thread suggested that <span class="math inline">\(\delta t\)</span> should be chosen in alignment with <span class="math inline">\(\tau\)</span>. Of course, there is some influence of the chosen time constant <span class="math inline">\(\tau\)</span>, as the smaller the leakage during a timestep, the smaller the error of membrane potential that can happen. However, I am skeptical of this notion due to the stochastic nature of Poisson spikes. Given that a spike can occur at any time during a timestep, it seems likely that the overestimation of membrane potential will roughly cancel out the underestimation. My hypothesis differs from this perspective. I contend that the crucial difference lies elsewhere. Specifically, owing to the nature of the simulation, a neuron can only emit a single spike within a given timestep. Consequently, the LIF neuron enters a sort of implicit refractory period for the duration of the timestep. When the timestep is exceedingly large - greater than 1 ms in this instance - the neuron experiences a prolonged refractory period, leading to the potential loss of critical input spikes as it is unable to integrate new input during this interval.</p>
<p>If the assumption is correct, i.e the timestep <span class="math inline">\(\delta t\)</span> if forcing an implicit refractory period, then having a large refractory period but with a smaller <span class="math inline">\(\delta t\)</span> should yield the same result as having a larger <span class="math inline">\(\delta t\)</span>. If we add a refractory period to the experiment above, we’ll see that they do indeed provide a similar effect:</p>
<div class="cell" data-execution_count="2">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">4</span>), tight_layout<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb2-2"><a href="#cb2-2"></a></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="cf">for</span> refractory_period <span class="kw">in</span> [<span class="fl">0.001</span>, <span class="fl">0.01</span>, <span class="fl">0.1</span>]:</span>
<span id="cb2-4"><a href="#cb2-4"></a>    spike_rates <span class="op">=</span> np.zeros((<span class="bu">len</span>(dts), nb_outputs)) <span class="co"># output</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>    <span class="cf">for</span> i, dt <span class="kw">in</span> <span class="bu">enumerate</span>(dts):</span>
<span id="cb2-6"><a href="#cb2-6"></a>        time <span class="op">=</span> np.arange(<span class="dv">0</span>, duration, dt)</span>
<span id="cb2-7"><a href="#cb2-7"></a>        refrac_clk <span class="op">=</span> <span class="bu">int</span>(refractory_period<span class="op">/</span>dt)</span>
<span id="cb2-8"><a href="#cb2-8"></a>        u <span class="op">=</span> np.zeros(nb_outputs)</span>
<span id="cb2-9"><a href="#cb2-9"></a>        refrac_cntr <span class="op">=</span> np.zeros(nb_outputs, dtype<span class="op">=</span><span class="bu">int</span>)</span>
<span id="cb2-10"><a href="#cb2-10"></a>        _exp <span class="op">=</span> np.exp(<span class="op">-</span>dt<span class="op">/</span>tau)</span>
<span id="cb2-11"><a href="#cb2-11"></a>        input_spikes <span class="op">=</span> np.random.poisson(lam<span class="op">=</span>input_rate<span class="op">*</span>dt, size<span class="op">=</span>(<span class="bu">len</span>(time), nb_inputs))</span>
<span id="cb2-12"><a href="#cb2-12"></a>        weighted_input_spikes <span class="op">=</span> input_spikes <span class="op">@</span> weights.T</span>
<span id="cb2-13"><a href="#cb2-13"></a>        spike_count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-14"><a href="#cb2-14"></a></span>
<span id="cb2-15"><a href="#cb2-15"></a>        <span class="cf">for</span> j, t <span class="kw">in</span> <span class="bu">enumerate</span>(time):</span>
<span id="cb2-16"><a href="#cb2-16"></a>            non_refrac_neurons <span class="op">=</span> refrac_cntr<span class="op">==</span><span class="dv">0</span></span>
<span id="cb2-17"><a href="#cb2-17"></a>            u[non_refrac_neurons] <span class="op">=</span> _exp <span class="op">*</span> u[non_refrac_neurons] <span class="op">+</span> weighted_input_spikes[j, non_refrac_neurons]</span>
<span id="cb2-18"><a href="#cb2-18"></a>            spikes <span class="op">=</span> u <span class="op">&gt;</span> thresh</span>
<span id="cb2-19"><a href="#cb2-19"></a>            spike_count <span class="op">+=</span> spikes</span>
<span id="cb2-20"><a href="#cb2-20"></a>            u[spikes] <span class="op">=</span> <span class="dv">0</span> <span class="co"># reset</span></span>
<span id="cb2-21"><a href="#cb2-21"></a></span>
<span id="cb2-22"><a href="#cb2-22"></a>            <span class="co"># Setup refractory period</span></span>
<span id="cb2-23"><a href="#cb2-23"></a>            refrac_cntr <span class="op">=</span> np.maximum(refrac_cntr<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>)</span>
<span id="cb2-24"><a href="#cb2-24"></a>            refrac_cntr[spikes] <span class="op">+=</span> refrac_clk</span>
<span id="cb2-25"><a href="#cb2-25"></a></span>
<span id="cb2-26"><a href="#cb2-26"></a>        spike_rates[i] <span class="op">+=</span> spike_count <span class="op">/</span> duration</span>
<span id="cb2-27"><a href="#cb2-27"></a></span>
<span id="cb2-28"><a href="#cb2-28"></a></span>
<span id="cb2-29"><a href="#cb2-29"></a>    ax.errorbar(dts<span class="op">*</span><span class="dv">1000</span>, spike_rates.mean(axis<span class="op">=</span><span class="dv">1</span>), yerr<span class="op">=</span>spike_rates.std(axis<span class="op">=</span><span class="dv">1</span>), capsize<span class="op">=</span><span class="dv">5</span>, label<span class="op">=</span><span class="ss">f"Refrac.: </span><span class="sc">{</span><span class="dv">1000</span><span class="op">*</span>refractory_period<span class="sc">:0.1f}</span><span class="ss">ms"</span>)</span>
<span id="cb2-30"><a href="#cb2-30"></a>    ax.set_xscale(<span class="st">"log"</span>)</span>
<span id="cb2-31"><a href="#cb2-31"></a>    ax.set_xlabel(<span class="st">"$</span><span class="ch">\\</span><span class="st">delta t$ [ms]"</span>)</span>
<span id="cb2-32"><a href="#cb2-32"></a>    ax.set_ylabel(<span class="st">"Output firing rate [sp/s]"</span>)</span>
<span id="cb2-33"><a href="#cb2-33"></a>    ax.legend(loc<span class="op">=</span><span class="st">"lower left"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-3-output-1.png" width="566" height="374" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>As we see, the output firing rates align when <span class="math inline">\(\delta t\)</span> is equal to the refractory period. For example, at <span class="math inline">\(\delta t=10\)</span> ms, the orange line only starts going down when the timestep becomes bigger than the explicit refractory period. Therefore, the model is actually correct. The only difference is that we have to consider that the effective refractory period is equal to the maximum between <span class="math inline">\(\delta t\)</span> and the explicit refractory period.</p>
</section>
<section id="solution" class="level1">
<h1>Solution</h1>
<p>The solution to this problem is quite simple. As I said before, the timestep of the simulation forces an implicit refractory period because the neuron can only spike once per timstep. If we remove this limitation, then we should remove this implicit refractory period and the output firing rate should be constant regardless of the timestep.</p>
<p>To do so, we count the number of times the membrane potential <span class="math inline">\(u(t)\)</span> is above the threshold to estimate how many times the neuron would spike in one timestep. <span class="math inline">\(n_{spikes}(t)=\lfloor \frac{\max \{u(t), 0\}}{u_{thresh}} \rfloor\)</span>. We also edit the reset, such that we remove the threshold from the membrane potential <span class="math inline">\(n_{spikes}\)</span> times, referred to as a soft-reset. This reset mechanism is more precise when dealing with large timesteps, as the accumulated membrane potential is not wasted by an early spike during a timestep. We re-simulate the first experiment with this modification, and we obtain:</p>
<div class="cell" data-execution_count="3">
<details class="code-fold">
<summary>Code</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode numberSource python number-lines code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a>np.random.seed(<span class="bn">0x1B</span>)</span>
<span id="cb3-2"><a href="#cb3-2"></a>fig, ax <span class="op">=</span> plt.subplots(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">4</span>), tight_layout<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb3-3"><a href="#cb3-3"></a>spike_rates <span class="op">=</span> np.zeros((<span class="bu">len</span>(dts), nb_outputs)) <span class="co"># output</span></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="cf">for</span> i, dt <span class="kw">in</span> <span class="bu">enumerate</span>(dts):</span>
<span id="cb3-5"><a href="#cb3-5"></a>    time <span class="op">=</span> np.arange(<span class="dv">0</span>, duration, dt)</span>
<span id="cb3-6"><a href="#cb3-6"></a>    u <span class="op">=</span> np.zeros(nb_outputs)</span>
<span id="cb3-7"><a href="#cb3-7"></a>    _exp <span class="op">=</span> np.exp(<span class="op">-</span>dt<span class="op">/</span>tau)</span>
<span id="cb3-8"><a href="#cb3-8"></a>    input_spikes <span class="op">=</span> np.random.poisson(lam<span class="op">=</span>input_rate<span class="op">*</span>dt, size<span class="op">=</span>(<span class="bu">len</span>(time), nb_inputs))</span>
<span id="cb3-9"><a href="#cb3-9"></a>    weighted_input_spikes <span class="op">=</span> input_spikes <span class="op">@</span> weights.T</span>
<span id="cb3-10"><a href="#cb3-10"></a>    spike_count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb3-11"><a href="#cb3-11"></a></span>
<span id="cb3-12"><a href="#cb3-12"></a>    <span class="cf">for</span> j, t <span class="kw">in</span> <span class="bu">enumerate</span>(time):</span>
<span id="cb3-13"><a href="#cb3-13"></a>        u <span class="op">=</span> _exp <span class="op">*</span> u <span class="op">+</span> weighted_input_spikes[j]</span>
<span id="cb3-14"><a href="#cb3-14"></a>        <span class="co">#previous code: spikes = u &gt; thresh</span></span>
<span id="cb3-15"><a href="#cb3-15"></a>        spikes <span class="op">=</span> np.floor(np.maximum(u, <span class="dv">0</span>) <span class="op">/</span> thresh) <span class="co"># multiple spikes</span></span>
<span id="cb3-16"><a href="#cb3-16"></a>        spike_count <span class="op">+=</span> spikes</span>
<span id="cb3-17"><a href="#cb3-17"></a>        u <span class="op">-=</span> spikes<span class="op">*</span>thresh</span>
<span id="cb3-18"><a href="#cb3-18"></a>        <span class="co">#u[spikes &gt; 0] = 0 </span></span>
<span id="cb3-19"><a href="#cb3-19"></a></span>
<span id="cb3-20"><a href="#cb3-20"></a>    spike_rates[i] <span class="op">+=</span> spike_count <span class="op">/</span> duration</span>
<span id="cb3-21"><a href="#cb3-21"></a>ax.errorbar(dts<span class="op">*</span><span class="dv">1000</span>, spike_rates.mean(axis<span class="op">=</span><span class="dv">1</span>), yerr<span class="op">=</span>spike_rates.std(axis<span class="op">=</span><span class="dv">1</span>), capsize<span class="op">=</span><span class="dv">5</span>,)</span>
<span id="cb3-22"><a href="#cb3-22"></a>ax.set_xscale(<span class="st">"log"</span>)</span>
<span id="cb3-23"><a href="#cb3-23"></a>ax.set_xlabel(<span class="st">"$</span><span class="ch">\\</span><span class="st">delta t$ [ms]"</span>)</span>
<span id="cb3-24"><a href="#cb3-24"></a>ax.set_ylabel(<span class="st">"Output firing rate [sp/s]"</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="index_files/figure-html/cell-4-output-1.png" width="566" height="374" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<p>And voilà! We get the expected firing rate across all the timesteps. While this solution is very interesting for computational neuroscientists, it partly removes the energy friendliness of spiking neural networks since they are not binary anymore, and the reset involves some arithmetic.</p>


</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" id="quarto-citation"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX citation:</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@online{balafrej2023,
  author = {Balafrej, Ismael},
  title = {Selection of a Timestep for {SNN} Simulation},
  date = {2023-03-19},
  url = {https://ibalafrej.com/posts/2023-03-18-dt-vs-lif/},
  langid = {en}
}
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-balafrej2023" class="csl-entry quarto-appendix-citeas" role="listitem">
Balafrej, Ismael. 2023. <span>“Selection of a Timestep for SNN
Simulation.”</span> March 19, 2023. <a href="https://ibalafrej.com/posts/2023-03-18-dt-vs-lif/">https://ibalafrej.com/posts/2023-03-18-dt-vs-lif/</a>.
</div></div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/ibalafrej\.com");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>